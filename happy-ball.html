<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Happy Ball - Ocean Adventure</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            width: 100%; 
            height: 100%; 
            overflow: hidden;
        }
        
        #game { 
            width: 100%; 
            height: 100%; 
            display: block;
        }
        
        #ui {
            position: fixed;
            top: 15px;
            left: 0;
            right: 0;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }
        
        #score { 
            font-size: 2.2rem; 
            font-weight: bold; 
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700, 0 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 2px;
        }
        
        #hint { 
            font-size: 0.85rem; 
            color: rgba(255,255,255,0.8); 
            margin-top: 5px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        
        #level {
            position: fixed;
            top: 15px;
            left: 15px;
            font-size: 0.9rem;
            color: #00d4ff;
            z-index: 100;
            text-shadow: 0 0 10px #00d4ff;
        }
        
        #restart, #win {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
            border: none;
            padding: 18px 45px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            z-index: 200;
            display: none;
            box-shadow: 0 5px 30px rgba(56, 239, 125, 0.4);
            font-weight: bold;
        }
        
        #win {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            box-shadow: 0 5px 30px rgba(245, 87, 108, 0.4);
        }
        
        /* Ocean Background */
        .ocean-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: linear-gradient(180deg, 
                #001d3d 0%, 
                #003566 30%, 
                #006d77 60%, 
                #83c5be 100%);
        }
        
        /* Waves */
        .wave {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 100px;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 120"><path fill="%2383c5be" fill-opacity="0.3" d="M0,60 C300,120 600,0 900,60 C1200,120 1200,120 1200,120 L1200,0 L0,0 Z"/></svg>');
            animation: wave 8s linear infinite;
        }
        
        .wave:nth-child(2) {
            bottom: 10px;
            opacity: 0.5;
            animation: wave 12s linear infinite reverse;
        }
        
        .wave:nth-child(3) {
            bottom: 20px;
            opacity: 0.3;
            animation: wave 10s linear infinite;
        }
        
        @keyframes wave {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* Bubbles */
        .bubble {
            position: absolute;
            bottom: -50px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(255,255,255,0.1));
            border-radius: 50%;
            animation: rise linear infinite;
        }
        
        @keyframes rise {
            0% { transform: translateY(0) translateX(0); opacity: 0.6; }
            50% { transform: translateY(-50vh) translateX(20px); opacity: 0.8; }
            100% { transform: translateY(-100vh) translateX(-10px); opacity: 0; }
        }
        
        /* Seaweed */
        .seaweed {
            position: absolute;
            bottom: 0;
            width: 30px;
            animation: sway 3s ease-in-out infinite;
            transform-origin: bottom center;
        }
        
        @keyframes sway {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        
        /* Light rays */
        .light-rays {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, 
                rgba(255,255,255,0.1) 0%, 
                transparent 50%);
            pointer-events: none;
            z-index: 1;
        }
        
        /* Caustics effect */
        .caustics {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(0,200,255,0.1) 0%, transparent 40%),
                radial-gradient(ellipse at 80% 30%, rgba(0,255,200,0.08) 0%, transparent 35%),
                radial-gradient(ellipse at 40% 60%, rgba(0,150,255,0.1) 0%, transparent 30%);
            animation: caustic 4s ease-in-out infinite alternate;
            pointer-events: none;
            z-index: 2;
        }
        
        @keyframes caustic {
            0% { opacity: 0.6; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.1); }
        }
        
        /* Floating particles */
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255,255,255,0.6);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0) scale(1); opacity: 0.6; }
            50% { transform: translateY(-30px) scale(1.5); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Ocean Background -->
    <div class="ocean-bg">
        <div class="light-rays"></div>
        <div class="caustics"></div>
        <div class="wave"></div>
        <div class="wave"></div>
        <div class="wave"></div>
    </div>
    
    <!-- Bubbles will be added by JS -->
    <div id="bubbles"></div>
    
    <!-- Seaweed decorations -->
    <div id="seaweed"></div>
    
    <!-- Floating particles -->
    <div id="particles"></div>
    
    <div id="level">LEVEL <span id="levelNum">1</span></div>
    <div id="ui">
        <div id="score">0</div>
        <div id="hint">ðŸŒŠ Draw paths to guide the jellyfish to the treasure! ðŸŒŠ</div>
    </div>
    <canvas id="game"></canvas>
    <button id="restart" onclick="restart()">ðŸ”„ Play Again</button>
    <button id="win" onclick="nextLevel()">ðŸ’Ž Next Level!</button>

    <script>
        // Generate bubbles
        const bubblesContainer = document.getElementById('bubbles');
        for (let i = 0; i < 20; i++) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            const size = Math.random() * 20 + 10;
            bubble.style.width = size + 'px';
            bubble.style.height = size + 'px';
            bubble.style.left = Math.random() * 100 + '%';
            bubble.style.animationDuration = (Math.random() * 5 + 5) + 's';
            bubble.style.animationDelay = Math.random() * 5 + 's';
            bubblesContainer.appendChild(bubble);
        }
        
        // Generate seaweed
        const seaweedContainer = document.getElementById('seaweed');
        for (let i = 0; i < 8; i++) {
            const seaweed = document.createElement('div');
            seaweed.className = 'seaweed';
            seaweed.innerHTML = `<svg width="30" height="80" viewBox="0 0 30 80">
                <path d="M15,80 Q5,60 15,40 Q25,20 15,0 Q5,20 15,40 Q25,60 15,80" fill="#0d5c4a" opacity="0.7"/>
                <path d="M10,80 Q0,60 10,40 Q20,20 10,0" fill="#1a8c5e" opacity="0.5"/>
            </svg>`;
            seaweed.style.left = (Math.random() * 95) + '%';
            seaweed.style.animationDelay = Math.random() * 2 + 's';
            seaweedContainer.appendChild(seaweed);
        }
        
        // Generate floating particles
        const particlesContainer = document.getElementById('particles');
        for (let i = 0; i < 15; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.top = Math.random() * 80 + '%';
            particle.style.animationDelay = Math.random() * 3 + 's';
            particlesContainer.appendChild(particle);
        }
        
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        let W, H;
        let ball = null;
        let lines = [];
        let cups = [];
        let currentLevel = 1;
        let score = 0;
        let gameRunning = true;
        let obstacles = [];
        
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Jellyfish (player)
        class Ball {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = 22;
                this.gravity = 0.35;
                this.bounce = 0.6;
                this.friction = 0.995;
                this.tentacles = [];
                this.angle = 0;
                for (let i = 0; i < 6; i++) {
                    this.tentacles.push({
                        offset: (i - 2.5) * 6,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
            
            update() {
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.x += this.vx;
                this.y += this.vy;
                
                this.angle += 0.05;
                
                if (this.x < this.radius) { this.x = this.radius; this.vx *= -this.bounce; }
                if (this.x > W - this.radius) { this.x = W - this.radius; this.vx *= -this.bounce; }
                if (this.y > H + 50 && gameRunning) {
                    document.getElementById('restart').style.display = 'block';
                    gameRunning = false;
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Glow
                const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 2.5);
                glow.addColorStop(0, 'rgba(255, 105, 180, 0.6)');
                glow.addColorStop(0.5, 'rgba(255, 105, 180, 0.2)');
                glow.addColorStop(1, 'rgba(255, 105, 180, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Body (bell)
                ctx.beginPath();
                ctx.arc(0, -5, this.radius, Math.PI, 0);
                ctx.quadraticCurveTo(this.radius, 5, 0, 5);
                ctx.quadraticCurveTo(-this.radius, 5, -this.radius, -5);
                const bodyGrad = ctx.createLinearGradient(0, -this.radius, 0, 10);
                bodyGrad.addColorStop(0, '#ff69b4');
                bodyGrad.addColorStop(0.5, '#ff1493');
                bodyGrad.addColorStop(1, '#db7093');
                ctx.fillStyle = bodyGrad;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Inner glow
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 200, 230, 0.5)';
                ctx.fill();
                
                // Tentacles
                ctx.strokeStyle = '#ff69b4';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                this.tentacles.forEach(t => {
                    ctx.beginPath();
                    const baseX = t.offset;
                    const sway = Math.sin(this.angle + t.phase) * 8;
                    ctx.moveTo(baseX, 5);
                    ctx.quadraticCurveTo(baseX + sway, 20, baseX + sway * 0.5, 35);
                    ctx.stroke();
                });
                
                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-6, -8, 5, 0, Math.PI * 2);
                ctx.arc(6, -8, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(-5, -7, 2.5, 0, Math.PI * 2);
                ctx.arc(7, -7, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Pearl path (player drawn)
        class Line {
            constructor(points) {
                this.points = points;
            }
            
            draw() {
                if (this.points.length < 2) return;
                
                // Outer glow
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                
                // Main line
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                // Inner bright line
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Pearls along the line
                for (let i = 0; i < this.points.length; i += 8) {
                    const p = this.points[i];
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                }
            }
            
            checkCollision(ball) {
                for (let i = 0; i < this.points.length - 1; i++) {
                    let p1 = this.points[i];
                    let p2 = this.points[i + 1];
                    
                    let dx = p2.x - p1.x;
                    let dy = p2.y - p1.y;
                    let len = Math.sqrt(dx * dx + dy * dy);
                    if (len === 0) continue;
                    
                    let t = Math.max(0, Math.min(1, ((ball.x - p1.x) * dx + (ball.y - p1.y) * dy) / (len * len)));
                    let closestX = p1.x + t * dx;
                    let closestY = p1.y + t * dy;
                    
                    let distX = ball.x - closestX;
                    let distY = ball.y - closestY;
                    let dist = Math.sqrt(distX * distX + distY * distY);
                    
                    if (dist < ball.radius + 5) {
                        let nx = distX / dist;
                        let ny = distY / dist;
                        ball.vx += nx * 4;
                        ball.vy += ny * 4;
                        ball.x = closestX + nx * (ball.radius + 6);
                        ball.y = closestY + ny * (ball.radius + 6);
                    }
                }
            }
        }
        
        // Treasure chest (goal)
        class Cup {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 70;
                this.height = 55;
                this.filled = false;
                this.shimmer = 0;
            }
            
            draw() {
                this.shimmer += 0.08;
                
                // Glow
                const glow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.width);
                glow.addColorStop(0, this.filled ? 'rgba(255,215,0,0.6)' : 'rgba(255,215,0,0.3)');
                glow.addColorStop(1, 'rgba(255,215,0,0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2);
                ctx.fill();
                
                // Chest body
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(this.x - 30, this.y - 15, 60, 35);
                
                // Chest lid
                ctx.fillStyle = '#A0522D';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y - 15, 30, 12, 0, Math.PI, 0);
                ctx.fill();
                
                // Gold trim
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x - 30, this.y - 15, 60, 35);
                
                // Lock
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(this.x, this.y - 5, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Sparkles
                if (!this.filled) {
                    for (let i = 0; i < 4; i++) {
                        const angle = this.shimmer + i * Math.PI / 2;
                        const dist = 25 + Math.sin(this.shimmer * 2 + i) * 10;
                        const sx = this.x + Math.cos(angle) * dist;
                        const sy = this.y + Math.sin(angle) * dist;
                        
                        ctx.beginPath();
                        ctx.arc(sx, sy, 2, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255,215,0,${0.5 + Math.sin(this.shimmer * 3 + i) * 0.5})`;
                        ctx.fill();
                    }
                }
                
                // Opened lid when filled
                if (this.filled) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - 25, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rays
                    for (let i = 0; i < 8; i++) {
                        const angle = this.shimmer + i * Math.PI / 4;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - 25);
                        ctx.lineTo(this.x + Math.cos(angle) * 30, this.y - 25 + Math.sin(angle) * 30);
                        ctx.strokeStyle = `rgba(255,215,0,${0.5 + Math.sin(this.shimmer * 2 + i) * 0.3})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
            
            checkCollision(ball) {
                if (ball.x > this.x - 30 && ball.x < this.x + 30 &&
                    ball.y > this.y - 30 && ball.y < this.y + 20 && !this.filled) {
                    this.filled = true;
                    score += 150 * currentLevel;
                    document.getElementById('score').textContent = score;
                    gameRunning = false;
                    document.getElementById('win').style.display = 'block';
                }
            }
        }
        
        // Coral obstacle
        class Obstacle {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.color = ['#ff6b6b', '#ffa07a', '#ffb6c1', '#dda0dd'][Math.floor(Math.random() * 4)];
            }
            
            draw() {
                // Main body
                const grad = ctx.createLinearGradient(this.x, this.y, this.x + this.w, this.y + this.h);
                grad.addColorStop(0, this.color);
                grad.addColorStop(1, '#2d1f1f');
                ctx.fillStyle = grad;
                
                // Rounded rectangle with curves
                ctx.beginPath();
                ctx.moveTo(this.x + 5, this.y);
                ctx.lineTo(this.x + this.w - 5, this.y);
                ctx.quadraticCurveTo(this.x + this.w, this.y, this.x + this.w, this.y + 5);
                ctx.lineTo(this.x + this.w, this.y + this.h - 5);
                ctx.quadraticCurveTo(this.x + this.w, this.y + this.h, this.x + this.w - 5, this.y + this.h);
                ctx.lineTo(this.x + 5, this.y + this.h);
                ctx.quadraticCurveTo(this.x, this.y + this.h, this.x, this.y + this.h - 5);
                ctx.lineTo(this.x, this.y + 5);
                ctx.quadraticCurveTo(this.x, this.y, this.x + 5, this.y);
                ctx.fill();
                
                // Highlights
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x + 5, this.y + 3);
                ctx.lineTo(this.x + this.w - 10, this.y + 3);
                ctx.stroke();
            }
            
            checkCollision(ball) {
                if (ball.x + ball.radius > this.x && ball.x - ball.radius < this.x + this.w &&
                    ball.y + ball.radius > this.y && ball.y - ball.radius < this.y + this.h) {
                    
                    let l = ball.x - this.x;
                    let r = (this.x + this.w) - ball.x;
                    let t = ball.y - this.y;
                    let b = (this.y + this.h) - ball.y;
                    
                    let min = Math.min(l, r, t, b);
                    
                    if (min === t) {
                        ball.y = this.y - ball.radius;
                        ball.vy *= -ball.bounce;
                    } else if (min === b) {
                        ball.y = this.y + this.h + ball.radius;
                        ball.vy *= -ball.bounce;
                    } else if (min === l) {
                        ball.x = this.x - ball.radius;
                        ball.vx *= -ball.bounce;
                    } else {
                        ball.x = this.x + this.w + ball.radius;
                        ball.vx *= -ball.bounce;
                    }
                }
            }
        }
        
        function initLevel(level) {
            ball = new Ball(W/2, 60);
            lines = [];
            cups = [new Cup(W/2, H - 80)];
            obstacles = [];
            
            if (level === 1) {
                obstacles.push(new Obstacle(W/2 - 100, H/2, 200, 20));
                obstacles.push(new Obstacle(30, H/2 + 100, 120, 20));
                obstacles.push(new Obstacle(W - 150, H/2 + 100, 120, 20));
            } else if (level === 2) {
                obstacles.push(new Obstacle(W/2 - 60, H/3, 120, 20));
                obstacles.push(new Obstacle(20, H/2, 100, 20));
                obstacles.push(new Obstacle(W - 120, H/2, 100, 20));
                obstacles.push(new Obstacle(W/2 - 80, H*2/3, 160, 20));
            } else if (level === 3) {
                obstacles.push(new Obstacle(W/2 - 80, H/4, 160, 20));
                obstacles.push(new Obstacle(50, H/2 - 30, 80, 20));
                obstacles.push(new Obstacle(W - 130, H/2 - 30, 80, 20));
                obstacles.push(new Obstacle(W/2 - 40, H/2 + 40, 80, 20));
                obstacles.push(new Obstacle(50, H*3/4, 80, 20));
                obstacles.push(new Obstacle(W - 130, H*3/4, 80, 20));
            } else {
                for (let i = 0; i < level + 1; i++) {
                    obstacles.push(new Obstacle(
                        Math.random() * (W - 150) + 75,
                        H/3 + Math.random() * H/3,
                        Math.random() * 80 + 40,
                        15
                    ));
                }
            }
            
            gameRunning = true;
            document.getElementById('restart').style.display = 'none';
            document.getElementById('win').style.display = 'none';
            document.getElementById('levelNum').textContent = level;
        }
        
        function restart() {
            currentLevel = 1;
            score = 0;
            document.getElementById('score').textContent = score;
            initLevel(currentLevel);
        }
        
        function nextLevel() {
            currentLevel++;
            score += 100 * currentLevel;
            document.getElementById('score').textContent = score;
            initLevel(currentLevel);
        }
        
        let currentLine = [];
        let drawing = false;
        
        canvas.addEventListener('mousedown', e => {
            if (gameRunning) {
                drawing = true;
                currentLine = [{x: e.clientX, y: e.clientY}];
            }
        });
        
        canvas.addEventListener('mousemove', e => {
            if (drawing && gameRunning) {
                currentLine.push({x: e.clientX, y: e.clientY});
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            if (currentLine.length > 2) lines.push(new Line([...currentLine]));
            drawing = false;
            currentLine = [];
        });
        
        canvas.addEventListener('touchstart', e => {
            if (gameRunning) {
                drawing = true;
                currentLine = [{x: e.touches[0].clientX, y: e.touches[0].clientY}];
            }
        });
        
        canvas.addEventListener('touchmove', e => {
            if (drawing && gameRunning) {
                e.preventDefault();
                currentLine.push({x: e.touches[0].clientX, y: e.touches[0].clientY});
            }
        });
        
        canvas.addEventListener('touchend', () => {
            if (currentLine.length > 2) lines.push(new Line([...currentLine]));
            drawing = false;
            currentLine = [];
        });
        
        function update() {
            ctx.clearRect(0, 0, W, H);
            
            // Draw obstacles
            obstacles.forEach(o => {
                o.draw();
                if (gameRunning && ball) o.checkCollision(ball);
            });
            
            // Draw lines
            lines.forEach(l => {
                l.draw();
                if (gameRunning && ball) l.checkCollision(ball);
            });
            
            // Draw current line
            if (currentLine.length > 1) {
                ctx.beginPath();
                ctx.moveTo(currentLine[0].x, currentLine[0].y);
                currentLine.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Draw cup (treasure)
            cups.forEach(c => {
                c.draw();
                if (gameRunning && ball) c.checkCollision(ball);
            });
            
            // Draw ball (jellyfish)
            if (ball) {
                ball.update();
                ball.draw();
            }
            
            requestAnimationFrame(update);
        }
        
        initLevel(1);
        update();
    </script>
</body>
</html>
